<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bip39 GPU bruteforce benchmark</title>
  <script src="webgpu.js"></script>
</head>
    <style>
        html, body {
            width: 100%;
            box-sizing: border-box;
            background-color: #222;
            font-size: 15px;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            color: bisque;
        }
        html {
            padding: 0;
        }
        body {
            padding: 20px;
        }
        button {
            background-color: #222;
            color: bisque;
            width: 100%;
            height: 40px;
            margin-top: 20px;
        }
        pre {
            text-wrap: auto;
        }
    </style>
<body>
    <button id="benchmark">Start benchmark</button>
    <pre id="output"></pre>
</body>
<script>
window.benchmark.onclick = async () => {
    assert(window.isSecureContext, 'WebGPU disabled for http:// protocol, works only on https://')
    assert(navigator.gpu, 'Browser not support WebGPU')
    window.benchmark.style.display = 'none'
    const adapter1 = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" })
    const device1 = await adapter1.requestDevice()
    await runBenchmark({ device: device1, adapter: adapter1 })

    // const adapter2 = await navigator.gpu.requestAdapter({ powerPreference: "low-power" })
    // const device2 = await adapter2.requestDevice()
    // if (adapter1.info.device !== adapter2.info.device || adapter1.info.description !== adapter2.info.description) {
    //     window.output.innerHTML += '\n'
    //     await runBenchmark({ device: device2, adapter: adapter2 })
    // }
    log('\n✅ DONE')
    window.benchmark.style.display = ''
}

const TESTS = {
    'mnemonic checker': async function ({ passwords, WORKGROUP_SIZE }, gpu) {
        let mnemonicFilterCode = (await fetch('wgsl/mnemonic_checker.wgsl').then(r => r.text()))
            .replaceAll('WORKGROUP_SIZE', WORKGROUP_SIZE.toString(10))
        const shaders = [await gpu.buildShader(mnemonicFilterCode, 'main', WORKGROUP_SIZE)]
        const inp = new Uint32Array(8 * passwords)
        return { shaders, inp, check(out) {
            console.log('hash:', u32arrToHex(out.slice(0, 8)))
            console.log('hash:', '1402a3971f424aeccd307c7585cbda8779491e41877182ea49003a868fd5846c')
            console.log('out[0]:', out[0].toString(16))
            return u32arrToHex(out.slice(0, 8)) === '1402a3971f424aeccd307c7585cbda8779491e41877182ea49003a868fd5846c'
        } }
    },
    'ed25519': async function ({ passwords, WORKGROUP_SIZE }, gpu) {
        await gpu.setEccTable('ed25519')
        var pkList = [base58Decode('HDxSyFTFenjCwLRg3VVdm3jD4zyTf1ZStcG1TmiQC6u9')]
        let ed25519code = (await fetch('wgsl/ed25519.wgsl').then(r => r.text()))
            .replaceAll('WORKGROUP_SIZE', WORKGROUP_SIZE.toString(10))
            .replaceAll('CHECK_COUNT', pkList.length.toString(10))
            .replaceAll('CHECK_KEYS', solanaPkListToWGSLArray(pkList))
        const shaders = [await gpu.buildShader(ed25519code, 'main', WORKGROUP_SIZE)]
        const inp = new Uint32Array(8 * passwords)
        const privKeyFalse = hexToUint32Array('09ffcb448f752fd52d656882451e24a80e4dbbbc0a71ec83b8d3d720503c3484')
        privKeyFalse[0] = 0;
        for (let i = 0; i < passwords; i++) {
            inp.set(privKeyFalse, i*8)
        }
        const privKey = hexToUint32Array('09ffcb448f752fd52d656882451e24a80e4dbbbc0a71ec83b8d3d720503c3484')
        inp.set(privKey, 35*8)

        return { shaders, inp, check(out) { return out[0] === 35 } }
    },
    'secp256k1': async function ({ passwords, WORKGROUP_SIZE }, gpu) {
        await gpu.setEccTable('secp256k1')
        let secp256k1Code = (await fetch('wgsl/secp256k1.wgsl').then(r => r.text()))
            .replaceAll('WORKGROUP_SIZE', WORKGROUP_SIZE.toString(10))
        const shaders = [await gpu.buildShader(secp256k1Code, 'main', WORKGROUP_SIZE)]
        const inp = new Uint32Array(16 * passwords)
        const privKey = hexToUint32Array('597fc6a34994b21cc9ef71aef1e05b35c6eb693fd9038ca250fb786204b5c552')
        for (let i = 0; i < passwords; i++) {
            inp.set(privKey, i*16)
        }
        return { shaders, inp, check(out) {
            return u32arrToHex(out.slice(16, 32)) === 'b63e537acee9c54acaa717904221830ddb7b36a1545894c489165ed352538f57401934fe501d96447efbe1ddb4e5b831f6fe1c0b7239fc0de39b88700cebf64a'
        } }
    },
    'solana': async function ({ passwords, WORKGROUP_SIZE }, gpu) {
        let deriveCode = (await fetch('wgsl/derive_coin.wgsl').then(r => r.text()))
                .replaceAll('WORKGROUP_SIZE', WORKGROUP_SIZE.toString(10))
                .replaceAll('NETWORK', 44)
                .replaceAll('COIN_TYPE', 501)
                .replaceAll('ADDR_COUNT', `${1}u`)
        const shaders = [await gpu.buildShader(deriveCode, 'deriveSolana', WORKGROUP_SIZE)]
        const inp = new Uint32Array(16 * passwords)
        const seed = hexToUint32Array('2177a1d6e983977c6b8e1b2214da6e61651d878d2c002024d086ee0e50626f0cf3890c740d8c425380397c61395ff2147d49d068be6a68d3e8b775e7a20c20ed')
        for (let i = 0; i < passwords; i++) {
            inp.set(seed, i * 16)
        }
        return { shaders, inp, check(out) {
            return u32arrToHex(out.slice(0, 8)) === '09ffcb448f752fd52d656882451e24a80e4dbbbc0a71ec83b8d3d720503c3484'
        } }
    },
    'pbkdf2': async function ({ passwords, MNEMONIC, WORKGROUP_SIZE }, gpu) {
        let pbkdf2Code = (await fetch('wgsl/pbkdf2_template.wgsl').then(r => r.text()))
        pbkdf2Code = (await unrolledSha512_wgpu(pbkdf2Code, MNEMONIC))
            .replaceAll('WORKGROUP_SIZE', WORKGROUP_SIZE.toString(10))
        const shaders = [await gpu.buildShader(pbkdf2Code, 'main', WORKGROUP_SIZE)]
        const PASSWORD = 'gauffers'
        const digits = passwords.toString(10).length
        const PASS_LEN = Math.ceil((PASSWORD.length + digits + 1) / 4) + 1
        const inp = new Uint32Array(32 + PASS_LEN * passwords).fill(0)
        var strbuf = new Uint8Array(inp.buffer, inp.byteOffset, inp.byteLength)

        let passwordOffset = 128 + passwords * 4
        for (let i = 0; i < passwords; i++) {
            const curPass = PASSWORD + (i === 35 ? '' : i.toString(10)) + '\n'
            strbuf.set(new TextEncoder().encode(curPass), passwordOffset)
            inp[32 + i] = passwordOffset
            passwordOffset += curPass.length
        }
        const MNEMONIC_SEED_0 = 'f3aef945a3078fcc058a7da12bcc37df8c0c075d80eac9ce9a5cd0e468fd29fb7401b8f787c4e47248ce529bfb1b34cee2c0ddb010cb0e169646b490e9e0ddf4'
        const MNEMONIC_SEED_5 = '53ae6afed8bd85ad9b5603e14ac8e4930c900c3e97c94c6a3d74a6e112a30807a4cf1ad804065107242db26844d49b11ea15e73a2ae7d04358161e040e9f360f'

        return { shaders, inp, check(out) {
            return (u32arrToHex(out.slice(0, 16)) === MNEMONIC_SEED_0 && u32arrToHex(out.slice(80, 96)) === MNEMONIC_SEED_5)
        } }
    },
    'mnemonic to address': async function ({ passwords, MNEMONIC, WORKGROUP_SIZE }, gpu) {
        await gpu.setEccTable('secp256k1')
        const shaders = await buildEntirePipeline({
            addrType: 'eth', addrCount: 1, MNEMONIC, WORKGROUP_SIZE, ...gpu,
            hashList: [hexToUint8Array('9f592002A9216B5eB3B00040df6a9EaE4792A0De')],
        })
        const PASSWORD = 'gauffers'
        const digits = passwords.toString(10).length
        const PASS_LEN = Math.ceil((PASSWORD.length + digits + 1) / 4) + 1
        const inp = new Uint32Array(32 + PASS_LEN * passwords).fill(0)
        var strbuf = new Uint8Array(inp.buffer, inp.byteOffset, inp.byteLength)

        let passwordOffset = 128 + passwords * 4
        for (let i = 0; i < passwords; i++) {
            const curPass = PASSWORD + (i === 35 ? '' : i.toString(10)) + '\n'
            strbuf.set(new TextEncoder().encode(curPass), passwordOffset)
            inp[32 + i] = passwordOffset
            passwordOffset += curPass.length
        }
        return { shaders, inp, check(out) { return out[0] === 35 } }
    },
}


async function runBenchmark(options) {
    log(`\n[${options.adapter.info.description || options.adapter.info.vendor}]\n`)
    const MNEMONIC = 'expose census trophy review common rebel ask depend build caught frame accident naive shiver inmate host assault fan tonight accident left useful tongue blood'
    const passwords = 1024 * 128
    const WORKGROUP_SIZE = 64
    const gpu = await webGPUinit({...options, BUF_SIZE: passwords*128 })

    for (let mode of ['mnemonic checker']) {
        log(`\n${mode}:`);
        const { inp, check, shaders } = await TESTS[mode]({ passwords, MNEMONIC, WORKGROUP_SIZE }, gpu);
        await new Promise(res => setTimeout(res, 100)) // flush text
        for (let i = 0; i < 1; i++) {
            let batchSize = 64 * (2 ** i), time = Infinity, out;
            for (let x = 0; x < 3; x++) {
                const start = performance.now()
                out = await gpu.inference({ shaders, inp, count: batchSize })
                time = Math.min(time, (performance.now() - start) / 1000)
            }
            if (TESTS[mode] && !check(out)) {
                log(`❌ ${mode} FAILED`)
                gpu.clean()
                return
            }

            log(`Batch: ${batchSize}, Speed: ${(batchSize / time) | 0} ops/s`);
            if (time > 1) { break }
        }
    }
    gpu.clean()
}

function base58Decode(str) {
  const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  const bytes = [0];
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    const value = alphabet.indexOf(char);
    if (value === -1) return null;
    let carry = value;
    for (let j = 0; j < bytes.length; j++) {
      carry += bytes[j] * 58;
      bytes[j] = carry & 0xff;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  }
  let zeros = 0;
  while (str[zeros] === '1') zeros++;
  const result = new Uint8Array(zeros + bytes.length);
  for (let i = 0; i < bytes.length; i++) {
    result[result.length - 1 - i] = bytes[i];
  }
  return result;
}
function hexToUint8Array(hexString) {
    const bytes = [];
    for (let i = 0; i < hexString.length; i += 2) {
        bytes.push(parseInt(hexString.substr(i, 2), 16));
    }
    return new Uint8Array(bytes);
}
function hexToUint32Array(hexString) {
    const bytes = [];
    for (let i = 0; i < hexString.length; i += 8) {
        bytes.push(parseInt(hexString.substr(i, 8), 16));
    }
    return new Uint32Array(bytes);
}
function bigTo32Array(bInt) {
    return hexToUint32Array(bInt.toString(16).padStart(64, '0'));
}
function u32arrToHex(u32arr) {
    return Array.from(u32arr).map(x => x.toString(16).padStart(8,'0')).join('');
}
function u8arrToHex(u8arr) {
    return Array.from(u8arr).map(x => x.toString(16).padStart(2,'0')).join('');
}
</script>
</html>