<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bip39 GPU bruteforce benchmark</title>
  <script src="webgpu.js"></script>
</head>
    <style>
        html, body {
            width: 100%;
            box-sizing: border-box;
            background-color: #222;
            font-size: 15px;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            color: bisque;
        }
        html {
            padding: 0;
        }
        body {
            padding: 20px;
        }
        button {
            background-color: #222;
            color: bisque;
            width: 100%;
            height: 40px;
            margin-top: 20px;
        }
        pre {
            text-wrap: auto;
        }
    </style>
<body>
    <button id="benchmark">Start benchmark</button>
    <pre id="output"></pre>
</body>
<script>
window.benchmark.onclick = async () => {
    assert(window.isSecureContext, 'WebGPU disabled for http:// protocol, works only on https://')
    assert(navigator.gpu, 'Browser not support WebGPU')
    window.benchmark.style.display = 'none'
    window.output.innerHTML += 'Precompute secp256k1 table... '
    const start = performance.now()
    log(`[${((performance.now() - start) / 1000).toFixed(1)}s]`)
    const adapter1 = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" })
    const device1 = await adapter1.requestDevice()
    await runBenchmark({ device: device1, adapter: adapter1 })

    // const adapter2 = await navigator.gpu.requestAdapter({ powerPreference: "low-power" })
    // const device2 = await adapter2.requestDevice()
    // if (adapter1.info.device !== adapter2.info.device || adapter1.info.description !== adapter2.info.description) {
    //     window.output.innerHTML += '\n'
    //     await runBenchmark({ device: device2, adapter: adapter2 })
    // }
    log('\n✅ DONE')
    window.benchmark.style.display = ''
}

function preparePasswordsInput(passwords) {
    const PASSWORD = 'gauffers'
    const digits = passwords.toString(10).length
    const PASS_LEN = Math.ceil((PASSWORD.length + digits + 1) / 4) + 1
    const inp = new Uint32Array(32 + PASS_LEN * passwords).fill(0)
    var strbuf = new Uint8Array(inp.buffer, inp.byteOffset, inp.byteLength)

    let passwordOffset = 128 + passwords * 4
    for (let i = 0; i < passwords; i++) {
        const curPass = PASSWORD + (i === 35 ? '' : i.toString(10)) + '\n'
        strbuf.set(new TextEncoder().encode(curPass), passwordOffset)
        inp[32 + i] = passwordOffset
        passwordOffset += curPass.length
    }
    return inp
}
function prepareSecp256input(passwords) {
    const inp = new Uint32Array(16 * passwords)
    const privKey = hexToUint32Array('597fc6a34994b21cc9ef71aef1e05b35c6eb693fd9038ca250fb786204b5c552')
    for (let i = 0; i < passwords; i++) {
        inp.set(privKey, i*16)
    }
    return inp
}
const P = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn
const ED25519_PRIVKEY = '597fc6a34994b21cc9ef71aef1e05b35c6eb693fd9038ca250fb786204b5c552'
const ED25519_MULT    = '347fc6a34994b21c5c94565641e05b35c6eb693fd9038ca250fb786657567764'
const ED25519_RES = ((BigInt('0x'+ED25519_PRIVKEY) - BigInt('0x'+ED25519_MULT)) % P).toString(16).padStart(64, '0')

const G = {
  X: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,
  Y: 46316835694926478169428394003475163141307993866256225615783033603165251855960n,
  Z: 1n,
  T: 46827403850823179245072216630277197565144205554125654976674165829533817101731n
}

const G1 = {
  x: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,
  y: 46316835694926478169428394003475163141307993866256225615783033603165251855960n,
  d2xy: 50237614328228664512531835696112167678046477356841409204013502641986506238568n
}

const G4 = {
  X: 23197316746682137658487753814694637550837603101346191093668207172644967360191n,
  Y: 55755159111342471132708473709989135413752952857057988548665654794180019744770n,
  Z: 1971637863633247841617451804960054392857332397230032358963871280450295096525n,
  T: 40539236718722673024053576499751733433162581194985029906778799683827034136039n
}

function prepareEd25519input(passwords) {
    const inp = new Uint32Array(64 * passwords)
    const privKey = hexToUint32Array(ED25519_PRIVKEY)
    const mult = hexToUint32Array(ED25519_MULT)
    for (let i = 0; i < passwords; i++) {
        inp.set(bigTo32Array(G.X), i*64)
        inp.set(bigTo32Array(G.Y), i*64 + 8)
        inp.set(bigTo32Array(G.Z), i*64 + 16)
        inp.set(bigTo32Array(G.T), i*64 + 24)
        inp.set(bigTo32Array(G1.x), i*64 + 32)
        inp.set(bigTo32Array(G1.y), i*64 + 40)
        inp.set(bigTo32Array(G1.d2xy), i*64 + 48)
    }
    return inp
}
const SECP_PUBKEY = 'b63e537acee9c54acaa717904221830ddb7b36a1545894c489165ed352538f57401934fe501d96447efbe1ddb4e5b831f6fe1c0b7239fc0de39b88700cebf64a'
const MNEMONIC_SEED_0 = 'f3aef945a3078fcc058a7da12bcc37df8c0c075d80eac9ce9a5cd0e468fd29fb7401b8f787c4e47248ce529bfb1b34cee2c0ddb010cb0e169646b490e9e0ddf4'
const MNEMONIC_SEED_5 = '53ae6afed8bd85ad9b5603e14ac8e4930c900c3e97c94c6a3d74a6e112a30807a4cf1ad804065107242db26844d49b11ea15e73a2ae7d04358161e040e9f360f'

async function runBenchmark(options) {
    const MNEMONIC = 'expose census trophy review common rebel ask depend build caught frame accident naive shiver inmate host assault fan tonight accident left useful tongue blood'
    const passwords = 1024// * 128
    const { name, clean, inference, buildShader, swapBuffers } =
        await webGPUinit({...options, eccType: 'ed25519', BUF_SIZE: passwords*128 })
    log(`\n[${name}]\n`)
    window.output.innerHTML += 'Initialize data... '
    const start = performance.now()
    const WORKGROUP_SIZE = 64
    // const pipeline = await buildEntirePipeline({
    //     addrType: 'eth', MNEMONIC, buildShader, swapBuffers, WORKGROUP_SIZE,
    //     hashList: [hexToUint8Array('9f592002A9216B5eB3B00040df6a9EaE4792A0De')],
    // })
    let ed25519code = (await fetch('wgsl/ed25519.wgsl').then(r => r.text())).replaceAll('WORKGROUP_SIZE', WORKGROUP_SIZE.toString(10))
    const passwordsInput = preparePasswordsInput(passwords)
    const secp256input = prepareSecp256input(passwords)
    const ed25519input = prepareEd25519input(passwords / 2)
    
    log(`[${((performance.now() - start) / 1000).toFixed(1)}s]\n`)
    let shaders = []
    let failed = false
    let inp = null
    function fail(text) {
        log(text)
        clean()
        failed = true
    }
    for (let mode of ['ed25519']) {
        if (mode === 'ed25519') {
            log('\nEd25519:')
            shaders.push(await buildShader(ed25519code, 'main', WORKGROUP_SIZE))
            inp = ed25519input
        }
        if (mode === 'secp256k1') {
            log('\nSecp256k1:')
            shaders = [pipeline[2]]
            inp = secp256input
        }
        if (mode === 'pbkdf2') {
            log('\nPbkdf2-hmac-sha512:')
            shaders = [pipeline[0]]
            inp = passwordsInput
        }
        if (mode === 'all') {
            log('\nMnemonic to address:')
            shaders = pipeline
            inp = passwordsInput
        }


        await new Promise(res => setTimeout(res, 100)) // flush text
        for (let i = 0; i < 1; i++) {
            const batchSize = 64 * (2 ** i)
            let time = Infinity
            let out
            for (let x = 0; x < 3; x++) {
                const start = performance.now()
                out = await inference({ shaders, inp, count: batchSize })
                time = Math.min(time, (performance.now() - start) / 1000)
            }
            if (mode === 'pbkdf2' && (u32arrToHex(out.slice(0, 16)) !== MNEMONIC_SEED_0 || u32arrToHex(out.slice(80, 96)) !== MNEMONIC_SEED_5)) {
                fail('❌ pbkdf2 FAILED')
            }
            if (mode === 'secp256k1' && (u32arrToHex(out.slice(16, 32)) !== SECP_PUBKEY)) {
                fail('❌ secp256k1 FAILED')
            }
            if (mode === 'ed25519' && (
                u32arrToHex(out.slice(0, 8)) !== G4.X.toString(16).padStart(64, '0') ||
                u32arrToHex(out.slice(8, 16)) !== G4.Y.toString(16).padStart(64, '0') ||
                u32arrToHex(out.slice(16, 24)) !== G4.Z.toString(16).padStart(64, '0') ||
                u32arrToHex(out.slice(24, 32)) !== G4.T.toString(16).padStart(64, '0')
            )) {
                fail('❌ ed25519 FAILED')
                console.log(' .x:', G4.X.toString(16).padStart(64, '0'))
                console.log('G.x:', u32arrToHex(out.slice(0, 8)))
                console.log(' .y:', G4.Y.toString(16).padStart(64, '0'))
                console.log('G.y:', u32arrToHex(out.slice(8, 16)))
                console.log(' .z:', G4.Z.toString(16).padStart(64, '0'))
                console.log('G.z:', u32arrToHex(out.slice(16, 24)))
                console.log(' .t:', G4.T.toString(16).padStart(64, '0'))
                console.log('G.t:', u32arrToHex(out.slice(24, 32)))
            }
            if (mode === 'all' && out[0] !== 35) {
                fail('❌ wgsl pipeline FAILED')
            }

            log(`Batch: ${batchSize}, Speed: ${(batchSize / time) | 0} ops/s`);
            if (failed) {
                clean()
                return
            }

            if (time > 1) {
                break
            }
        }
    }
    clean()
}
function hexToUint8Array(hexString) {
    const bytes = [];
    for (let i = 0; i < hexString.length; i += 2) {
        bytes.push(parseInt(hexString.substr(i, 2), 16));
    }
    return new Uint8Array(bytes);
}
function hexToUint32Array(hexString) {
    const bytes = [];
    for (let i = 0; i < hexString.length; i += 8) {
        bytes.push(parseInt(hexString.substr(i, 8), 16));
    }
    return new Uint32Array(bytes);
}
function bigTo32Array(bInt) {
    return hexToUint32Array(bInt.toString(16).padStart(64, '0'));
}
function u32arrToHex(u32arr) {
    return Array.from(u32arr).map(x => x.toString(16).padStart(8,'0')).join('');
}
</script>
</html>